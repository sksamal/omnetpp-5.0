<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OMNeT++ Simulation Library: cGate Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMNeT++ Simulation Library
   &#160;<span id="projectnumber">5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classomnetpp_1_1cGate.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classomnetpp_1_1cGate-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cGate Class Reference<div class="ingroups"><a class="el" href="group__SimCore.html">Simulation Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cgate_8h_source.html">cgate.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Represents a module gate. </p>
<p><a class="el" href="classomnetpp_1_1cGate.html" title="Represents a module gate. ">cGate</a> object are created and managed by modules; the user typically does not want to directly create or destroy <a class="el" href="classomnetpp_1_1cGate.html" title="Represents a module gate. ">cGate</a> objects. However, they are important if a simple module algorithm needs to know about its surroundings. </p>
</div><div class="dynheader">
Inheritance diagram for cGate:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classomnetpp_1_1cGate.png" usemap="#cGate_map" alt=""/>
  <map id="cGate_map" name="cGate_map">
<area href="classomnetpp_1_1cObject.html" title="Root of the OMNeT++ class hierarchy. cObject is a lightweight class without any data members..." alt="cObject" shape="rect" coords="0,0,85,24"/>
<area href="classomnetpp_1_1noncopyable.html" title="Utility class, to make it impossible to call the operator= and copy constructor of any class derived ..." alt="noncopyable" shape="rect" coords="95,0,180,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6414f30b8d52995e4efda7b7caf746df"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a6414f30b8d52995e4efda7b7caf746df">deliver</a> (<a class="el" href="classomnetpp_1_1cMessage.html">cMessage</a> *msg, <a class="el" href="group__SimTime.html#ga5a8189d996907ac38e69e6a4c50cf4ec">simtime_t</a> at)</td></tr>
<tr class="separator:a6414f30b8d52995e4efda7b7caf746df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions</div></td></tr>
<tr class="memitem:a441703007dcbefdee2058fa6ac45b876"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a441703007dcbefdee2058fa6ac45b876">getName</a> () const  override</td></tr>
<tr class="separator:a441703007dcbefdee2058fa6ac45b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3865e40926760534b5faa68d9b1a8df"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ab3865e40926760534b5faa68d9b1a8df">getFullName</a> () const  override</td></tr>
<tr class="separator:ab3865e40926760534b5faa68d9b1a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac764613051628e373bdd277d2dcc50bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ac764613051628e373bdd277d2dcc50bd">forEachChild</a> (<a class="el" href="classomnetpp_1_1cVisitor.html">cVisitor</a> *v) override</td></tr>
<tr class="separator:ac764613051628e373bdd277d2dcc50bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e94571d706500b3d1af108bd69be06"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a38e94571d706500b3d1af108bd69be06">info</a> () const  override</td></tr>
<tr class="separator:a38e94571d706500b3d1af108bd69be06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff82ccf31f4fffe8dda8efb2b380f3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#abff82ccf31f4fffe8dda8efb2b380f3a">getOwner</a> () const  override</td></tr>
<tr class="separator:abff82ccf31f4fffe8dda8efb2b380f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Connecting the gate.</div></td></tr>
<tr class="memitem:a2ccf25d786300fd3514ecd700c362514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a2ccf25d786300fd3514ecd700c362514">connectTo</a> (<a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *gate, <a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *channel=nullptr, bool leaveUninitialized=false)</td></tr>
<tr class="separator:a2ccf25d786300fd3514ecd700c362514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960705de531a20389fb29928d43258c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a960705de531a20389fb29928d43258c3">disconnect</a> ()</td></tr>
<tr class="separator:a960705de531a20389fb29928d43258c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2a0c93a66e514fe7a6ebcc631bed1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ade2a0c93a66e514fe7a6ebcc631bed1f">reconnectWith</a> (<a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *channel, bool leaveUninitialized=false)</td></tr>
<tr class="separator:ade2a0c93a66e514fe7a6ebcc631bed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transmission state.</div></td></tr>
<tr class="memitem:a9e3529d9cd372a21c53895a916712762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a9e3529d9cd372a21c53895a916712762">getTransmissionChannel</a> () const </td></tr>
<tr class="separator:a9e3529d9cd372a21c53895a916712762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c95bd3e6789a91503b70b3acecb66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a86c95bd3e6789a91503b70b3acecb66e">findTransmissionChannel</a> () const </td></tr>
<tr class="separator:a86c95bd3e6789a91503b70b3acecb66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0af0600d5e1da9d81e8d52d3e444da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#aed0af0600d5e1da9d81e8d52d3e444da">getIncomingTransmissionChannel</a> () const </td></tr>
<tr class="separator:aed0af0600d5e1da9d81e8d52d3e444da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece09f68af428e9b262ffb76b640ee6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#aece09f68af428e9b262ffb76b640ee6f">findIncomingTransmissionChannel</a> () const </td></tr>
<tr class="separator:aece09f68af428e9b262ffb76b640ee6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gate connectivity.</div></td></tr>
<tr class="memitem:a77e92339332cca84b80d3e79830481df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a77e92339332cca84b80d3e79830481df">getPreviousGate</a> () const </td></tr>
<tr class="separator:a77e92339332cca84b80d3e79830481df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03438d6cb4ec2a861c729f82335f7e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a03438d6cb4ec2a861c729f82335f7e89">getNextGate</a> () const </td></tr>
<tr class="separator:a03438d6cb4ec2a861c729f82335f7e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ba685a1e498ba22647e91fd6bcaf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#aa17ba685a1e498ba22647e91fd6bcaf2">getConnectionId</a> () const </td></tr>
<tr class="separator:aa17ba685a1e498ba22647e91fd6bcaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6bfa5cda168821e95a11397610496f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a5b6bfa5cda168821e95a11397610496f">getPathStartGate</a> () const </td></tr>
<tr class="separator:a5b6bfa5cda168821e95a11397610496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b67f6a8857e2d7e8326f8aafc7df80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a64b67f6a8857e2d7e8326f8aafc7df80">getPathEndGate</a> () const </td></tr>
<tr class="separator:a64b67f6a8857e2d7e8326f8aafc7df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d353255f15867f6c98a7a1d87d243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a7f7d353255f15867f6c98a7a1d87d243">pathContains</a> (<a class="el" href="classomnetpp_1_1cModule.html">cModule</a> *module, int gateId=-1)</td></tr>
<tr class="separator:a7f7d353255f15867f6c98a7a1d87d243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a38f2ea3c0b00d96f6f99db4e6c168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a22a38f2ea3c0b00d96f6f99db4e6c168">isConnectedOutside</a> () const </td></tr>
<tr class="separator:a22a38f2ea3c0b00d96f6f99db4e6c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca27fb38ca92ff6a93c8955ee0ef11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a56ca27fb38ca92ff6a93c8955ee0ef11">isConnectedInside</a> () const </td></tr>
<tr class="separator:a56ca27fb38ca92ff6a93c8955ee0ef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180fa55a4bf36580963bed9e3e09c227"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a180fa55a4bf36580963bed9e3e09c227">isConnected</a> () const </td></tr>
<tr class="separator:a180fa55a4bf36580963bed9e3e09c227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069277ac44de9fa0e5586d38565fab66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a069277ac44de9fa0e5586d38565fab66">isPathOK</a> () const </td></tr>
<tr class="separator:a069277ac44de9fa0e5586d38565fab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Display string.</div></td></tr>
<tr class="memitem:a874774b4a34846e019c7341998c26e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cDisplayString.html">cDisplayString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a874774b4a34846e019c7341998c26e91">getDisplayString</a> ()</td></tr>
<tr class="separator:a874774b4a34846e019c7341998c26e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca7be71b1a08f7272233e8b96c2591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a5fca7be71b1a08f7272233e8b96c2591">setDisplayString</a> (const char *dispstr)</td></tr>
<tr class="separator:a5fca7be71b1a08f7272233e8b96c2591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classomnetpp_1_1cObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classomnetpp_1_1cObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classomnetpp_1_1cObject.html">cObject</a></td></tr>
<tr class="memitem:a19c327c658826577208cd63317db3373 inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a19c327c658826577208cd63317db3373">cObject</a> ()</td></tr>
<tr class="separator:a19c327c658826577208cd63317db3373 inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88630a430d31cf2caf4abd8d857e6a inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a9f88630a430d31cf2caf4abd8d857e6a">cObject</a> (const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> &amp;other)</td></tr>
<tr class="separator:a9f88630a430d31cf2caf4abd8d857e6a inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe3a7f7ab9e37024e2ea482e12968de inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#aafe3a7f7ab9e37024e2ea482e12968de">~cObject</a> ()</td></tr>
<tr class="separator:aafe3a7f7ab9e37024e2ea482e12968de inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8854bcb69efa2af6f8c7cae3ee92bbf0 inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a8854bcb69efa2af6f8c7cae3ee92bbf0">getClassName</a> () const </td></tr>
<tr class="separator:a8854bcb69efa2af6f8c7cae3ee92bbf0 inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432e6710315c241729f8d6f492b6318a inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a432e6710315c241729f8d6f492b6318a">isName</a> (const char *s) const </td></tr>
<tr class="separator:a432e6710315c241729f8d6f492b6318a inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb39e4a93ad7710aeca9970ef17a15d inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#abbb39e4a93ad7710aeca9970ef17a15d">getFullPath</a> () const </td></tr>
<tr class="separator:abbb39e4a93ad7710aeca9970ef17a15d inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61b1c46391e86b19a6a9176605e59c7 inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#aa61b1c46391e86b19a6a9176605e59c7">getThisPtr</a> () const </td></tr>
<tr class="separator:aa61b1c46391e86b19a6a9176605e59c7 inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9363681f09d39d04631ec55eb15cb388 inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a9363681f09d39d04631ec55eb15cb388">detailedInfo</a> () const </td></tr>
<tr class="separator:a9363681f09d39d04631ec55eb15cb388 inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1cd9aeed4205dc0553d6cdc69f06ed inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a6a1cd9aeed4205dc0553d6cdc69f06ed">dup</a> () const </td></tr>
<tr class="separator:a6a1cd9aeed4205dc0553d6cdc69f06ed inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95affb0d0d508d477e182fcac8379afc inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a95affb0d0d508d477e182fcac8379afc">parsimPack</a> (<a class="el" href="classomnetpp_1_1cCommBuffer.html">cCommBuffer</a> *buffer) const </td></tr>
<tr class="separator:a95affb0d0d508d477e182fcac8379afc inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef56c03ddb3166c46048ed65b767a72 inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a9ef56c03ddb3166c46048ed65b767a72">parsimUnpack</a> (<a class="el" href="classomnetpp_1_1cCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>
<tr class="separator:a9ef56c03ddb3166c46048ed65b767a72 inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2c9566a92eedd883945ed9a5677bf inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#ac6d2c9566a92eedd883945ed9a5677bf">isOwnedObject</a> () const </td></tr>
<tr class="separator:ac6d2c9566a92eedd883945ed9a5677bf inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e891dff011a9e6a5ff3fda07962d13a inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a2e891dff011a9e6a5ff3fda07962d13a">findObject</a> (const char *name, bool deep=true)</td></tr>
<tr class="separator:a2e891dff011a9e6a5ff3fda07962d13a inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a0559d90e1a9de8a581ec3854c460a inherit pub_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#af0a0559d90e1a9de8a581ec3854c460a">copyNotSupported</a> () const </td></tr>
<tr class="separator:af0a0559d90e1a9de8a581ec3854c460a inherit pub_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Information about the gate.</h2></td></tr>
<tr class="memitem:adbf3252abddd72f9a5bb3c3f8624e253"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#adbf3252abddd72f9a5bb3c3f8624e253">getBaseName</a> () const </td></tr>
<tr class="separator:adbf3252abddd72f9a5bb3c3f8624e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ccd09f194e6d86017b0f447f08b408"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ab2ccd09f194e6d86017b0f447f08b408">getNameSuffix</a> () const </td></tr>
<tr class="separator:ab2ccd09f194e6d86017b0f447f08b408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29282c3089315ea720b8fdddac7dc746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cProperties.html">cProperties</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a29282c3089315ea720b8fdddac7dc746">getProperties</a> () const </td></tr>
<tr class="separator:a29282c3089315ea720b8fdddac7dc746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc641171fb699c1116758176cd3bf4ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cGate.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#afc641171fb699c1116758176cd3bf4ab">getType</a> () const </td></tr>
<tr class="separator:afc641171fb699c1116758176cd3bf4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e06faed2f4127c521db0e2b00d03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cModule.html">cModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a402e06faed2f4127c521db0e2b00d03e">getOwnerModule</a> () const </td></tr>
<tr class="separator:a402e06faed2f4127c521db0e2b00d03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dea697b9afe117d9a1bb72b50a37afd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a7dea697b9afe117d9a1bb72b50a37afd">getId</a> () const </td></tr>
<tr class="separator:a7dea697b9afe117d9a1bb72b50a37afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed9d8dbec28bf8536105047dc8f375e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a6ed9d8dbec28bf8536105047dc8f375e">isVector</a> () const </td></tr>
<tr class="separator:a6ed9d8dbec28bf8536105047dc8f375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508a49a5a1d64ee6ad40ea5b1f57045c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a508a49a5a1d64ee6ad40ea5b1f57045c">getBaseId</a> () const </td></tr>
<tr class="separator:a508a49a5a1d64ee6ad40ea5b1f57045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5775df451a32aa32fab7fac48a1c1e5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a5775df451a32aa32fab7fac48a1c1e5c">getIndex</a> () const </td></tr>
<tr class="separator:a5775df451a32aa32fab7fac48a1c1e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349f844a931904d2219c1ff9bbbff85b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a349f844a931904d2219c1ff9bbbff85b">getVectorSize</a> () const </td></tr>
<tr class="separator:a349f844a931904d2219c1ff9bbbff85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e4e3e2a7bf18888b71bdf9dda0770b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size</a> () const </td></tr>
<tr class="separator:ab8e4e3e2a7bf18888b71bdf9dda0770b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22afef0f1f4cc850559c2737bc43d4fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a22afef0f1f4cc850559c2737bc43d4fa">getChannel</a> () const </td></tr>
<tr class="separator:a22afef0f1f4cc850559c2737bc43d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06104078027d23c9b2c25e71702bbc70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a06104078027d23c9b2c25e71702bbc70">setDeliverOnReceptionStart</a> (bool d)</td></tr>
<tr class="separator:a06104078027d23c9b2c25e71702bbc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab972670969232cac2975464515fc6228"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#ab972670969232cac2975464515fc6228">getDeliverOnReceptionStart</a> () const </td></tr>
<tr class="separator:ab972670969232cac2975464515fc6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a85b045e20a88c11f98b4049085e34"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cGate.html#a34a85b045e20a88c11f98b4049085e34">getTypeName</a> (<a class="el" href="classomnetpp_1_1cGate.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a> t)</td></tr>
<tr class="separator:a34a85b045e20a88c11f98b4049085e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classomnetpp_1_1cObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classomnetpp_1_1cObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classomnetpp_1_1cObject.html">cObject</a></td></tr>
<tr class="memitem:a0f12f812ec24a2b8c9137da85268bf24 inherit pro_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a0f12f812ec24a2b8c9137da85268bf24">take</a> (<a class="el" href="classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *obj)</td></tr>
<tr class="separator:a0f12f812ec24a2b8c9137da85268bf24 inherit pro_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f73a8adf0bf38a045afcbd9babbd05 inherit pro_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a32f73a8adf0bf38a045afcbd9babbd05">drop</a> (<a class="el" href="classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *obj)</td></tr>
<tr class="separator:a32f73a8adf0bf38a045afcbd9babbd05 inherit pro_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d79054c2c4ee2e7738e0e0cd3555713 inherit pro_methods_classomnetpp_1_1cObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomnetpp_1_1cObject.html#a9d79054c2c4ee2e7738e0e0cd3555713">dropAndDelete</a> (<a class="el" href="classomnetpp_1_1cOwnedObject.html">cOwnedObject</a> *obj)</td></tr>
<tr class="separator:a9d79054c2c4ee2e7738e0e0cd3555713 inherit pro_methods_classomnetpp_1_1cObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a1d1cfd8ffb84e947f82999c682b666a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classomnetpp_1_1cGate.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gate type </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a441703007dcbefdee2058fa6ac45b876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the name of the the gate without the gate index in brackets. </p>

<p>Reimplemented from <a class="el" href="classomnetpp_1_1cObject.html#a70f88e8edc62f8abd5db1b0328eb7ee5">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="ab3865e40926760534b5faa68d9b1a8df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* getFullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full name of the gate, which is <a class="el" href="classomnetpp_1_1cGate.html#a441703007dcbefdee2058fa6ac45b876">getName()</a> plus the index in square brackets (e.g. "out[4]"). Redefined to add the index. </p>

<p>Reimplemented from <a class="el" href="classomnetpp_1_1cObject.html#ad1fc98ea6bfdb645f6d08cbc065245fc">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="ac764613051628e373bdd277d2dcc50bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void forEachChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cVisitor.html">cVisitor</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls v-&gt;visit(this) for each contained object. See <a class="el" href="classomnetpp_1_1cObject.html" title="Root of the OMNeT++ class hierarchy. cObject is a lightweight class without any data members...">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classomnetpp_1_1cObject.html#a6fbbab48c06f13814a0a7a71537ae500">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a38e94571d706500b3d1af108bd69be06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Produces a one-line description of the object's contents. See <a class="el" href="classomnetpp_1_1cObject.html" title="Root of the OMNeT++ class hierarchy. cObject is a lightweight class without any data members...">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classomnetpp_1_1cObject.html#a39640237e61d62b024692ae017b9efa3">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="abff82ccf31f4fffe8dda8efb2b380f3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classomnetpp_1_1cObject.html">cObject</a>* getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the owner module of this gate. </p>

<p>Reimplemented from <a class="el" href="classomnetpp_1_1cObject.html#acc646c6199a326bdff221c6995586adb">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a6414f30b8d52995e4efda7b7caf746df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool deliver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cMessage.html">cMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SimTime.html#ga5a8189d996907ac38e69e6a4c50cf4ec">simtime_t</a>&#160;</td>
          <td class="paramname"><em>at</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called internally by the send() functions and channel classes' <a class="el" href="classomnetpp_1_1cGate.html#a6414f30b8d52995e4efda7b7caf746df">deliver()</a> to deliver the message to its destination. A false return value means that the message object should be deleted by the caller. (This is used e.g. with parallel simulation, for messages leaving the partition.) </p>

</div>
</div>
<a class="anchor" id="a2ccf25d786300fd3514ecd700c362514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* connectTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaveUninitialized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects the gate to another gate, using the given channel object (if one is specified). This method can be used to manually create connections for dynamically created modules.</p>
<p>This method invokes callInitialize() on the channel object, unless the compound module containing this connection is not yet initialized (then it assumes that this channel will be initialized as part of the compound module initialization process.) To leave the channel uninitialized, specify true for the leaveUninitialized parameter.</p>
<p>If the gate is already connected, an error will occur. The gate argument cannot be nullptr, that is, you cannot use this function to disconnect a gate; use <a class="el" href="classomnetpp_1_1cGate.html#a960705de531a20389fb29928d43258c3">disconnect()</a> for that.</p>
<p>Note: When you set channel parameters after channel initialization, make sure the channel class is implemented so that the changes take effect; i.e. the channel should either override and properly handle handleParameterChange(), or should not cache any values from parameters. </p>

</div>
</div>
<a class="anchor" id="a960705de531a20389fb29928d43258c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects the gate, and also deletes the associated channel object if one has been set. <a class="el" href="classomnetpp_1_1cGate.html#a960705de531a20389fb29928d43258c3">disconnect()</a> must be invoked on the source gate ("from" side) of the connection.</p>
<p>The method has no effect if the gate is not connected. </p>

</div>
</div>
<a class="anchor" id="ade2a0c93a66e514fe7a6ebcc631bed1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* reconnectWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaveUninitialized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects the gate, then connects it again to the same gate, with the given channel object (if not nullptr). The gate must be connected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classomnetpp_1_1cGate.html#a2ccf25d786300fd3514ecd700c362514">connectTo()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbf3252abddd72f9a5bb3c3f8624e253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* getBaseName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gate name without index and potential "$i"/"$o" suffix. </p>

</div>
</div>
<a class="anchor" id="ab2ccd09f194e6d86017b0f447f08b408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* getNameSuffix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the suffix part of the gate name ("$i", "$o" or ""). </p>

</div>
</div>
<a class="anchor" id="a29282c3089315ea720b8fdddac7dc746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cProperties.html">cProperties</a>* getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the properties for this gate. Properties cannot be changed at runtime. </p>

</div>
</div>
<a class="anchor" id="afc641171fb699c1116758176cd3bf4ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cGate.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a> getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the gate's type, cGate::INPUT or cGate::OUTPUT. (It never returns cGate::INOUT, because a <a class="el" href="classomnetpp_1_1cGate.html" title="Represents a module gate. ">cGate</a> object is always either the input or the output half of an inout gate ("name$i" or "name$o"). </p>

</div>
</div>
<a class="anchor" id="a34a85b045e20a88c11f98b4049085e34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* getTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cGate.html#a1d1cfd8ffb84e947f82999c682b666a7">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the given type as a string. </p>

</div>
</div>
<a class="anchor" id="a402e06faed2f4127c521db0e2b00d03e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cModule.html">cModule</a>* getOwnerModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the owner module of the gate. </p>

</div>
</div>
<a class="anchor" id="a7dea697b9afe117d9a1bb72b50a37afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gate ID, which uniquely identifies the gate within the module. IDs are guaranteed to be contiguous within a gate vector: <code>module-&gt;gate(id+index) == module-&gt;gate(id)+index</code>.</p>
<p>Gate IDs are stable: they are guaranteed not to change during simulation. (This is a new feature of OMNeT++ 4.0. In earlier releases, gate IDs could change when the containing gate vector was resized.)</p>
<p>Note: As of OMNeT++ 4.0, gate IDs are no longer small integers, and cannot be used for iterating over the gates of a module. Use <a class="el" href="classomnetpp_1_1cModule_1_1GateIterator.html" title="Iterates through the gates of a module. ">cModule::GateIterator</a> for iteration. </p>

</div>
</div>
<a class="anchor" id="a6ed9d8dbec28bf8536105047dc8f375e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the gate is part of a gate vector. </p>

</div>
</div>
<a class="anchor" id="a508a49a5a1d64ee6ad40ea5b1f57045c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBaseId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the gate is part of a gate vector, returns the ID of the first element in the gate vector. Otherwise, it returns the gate's ID. </p>

</div>
</div>
<a class="anchor" id="a5775df451a32aa32fab7fac48a1c1e5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the gate is part of a gate vector, returns the gate's index in the vector. Otherwise, it returns 0. </p>

</div>
</div>
<a class="anchor" id="a349f844a931904d2219c1ff9bbbff85b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getVectorSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the gate is part of a gate vector, returns the size of the vector. For non-vector gates it returns 1.</p>
<p>The gate vector size can also be obtained by calling the <a class="el" href="classomnetpp_1_1cModule.html#a6d0193f83bb9f06e08b08e54bc1a88f2">cModule::gateSize()</a>. </p>

</div>
</div>
<a class="anchor" id="ab8e4e3e2a7bf18888b71bdf9dda0770b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="classomnetpp_1_1cGate.html#a349f844a931904d2219c1ff9bbbff85b">getVectorSize()</a>. </p>

</div>
</div>
<a class="anchor" id="a22afef0f1f4cc850559c2737bc43d4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* getChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the channel object attached to this gate, or nullptr if there is no channel. This is the channel between this gate and this-&gt;<a class="el" href="classomnetpp_1_1cGate.html#a03438d6cb4ec2a861c729f82335f7e89">getNextGate()</a>, that is, channels are stored on the "from" side of the connections. </p>

</div>
</div>
<a class="anchor" id="a06104078027d23c9b2c25e71702bbc70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDeliverOnReceptionStart </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method may only be invoked on input gates of simple modules. Messages with nonzero length then have a nonzero transmission duration (and thus, reception duration on the other side of the connection). By default, the delivery of the message to the module marks the end of the reception. Setting this bit will cause the channel to deliver the message to the module at the start of the reception. The duration that the reception will take can be extracted from the message object, by its getDuration() method. </p>

</div>
</div>
<a class="anchor" id="ab972670969232cac2975464515fc6228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool getDeliverOnReceptionStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether messages delivered through this gate will mark the start or the end of the reception process (assuming nonzero message length and data rate on the channel.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classomnetpp_1_1cGate.html#a06104078027d23c9b2c25e71702bbc70">setDeliverOnReceptionStart()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e3529d9cd372a21c53895a916712762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* getTransmissionChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typically invoked on an output gate, this method returns <em>the</em> channel in the connection path that supports datarate (as determined by <a class="el" href="classomnetpp_1_1cChannel.html#ac53b59d9f96b7607a5b47d198bce5f3a">cChannel::isTransmissionChannel()</a>; it is guaranteed that there can be at most one such channel per path). If there is no such channel, an error is thrown.</p>
<p>This method only checks the segment of the connection path that <em>starts</em> at this gate, so, for example, it is an error to invoke it on a simple module input gate.</p>
<p>Note: this method searches the connection path linearly, so at performance-critical places it may be better to cache its return value (provided that connections are not removed or created dynamically during simulation.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classomnetpp_1_1cChannel.html#ac53b59d9f96b7607a5b47d198bce5f3a">cChannel::isTransmissionChannel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86c95bd3e6789a91503b70b3acecb66e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* findTransmissionChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classomnetpp_1_1cGate.html#a9e3529d9cd372a21c53895a916712762">getTransmissionChannel()</a>, but returns nullptr instead of throwing an error if there is no transmission channel in the path. </p>

</div>
</div>
<a class="anchor" id="aed0af0600d5e1da9d81e8d52d3e444da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* getIncomingTransmissionChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typically invoked on an input gate, this method searches the reverse path (i.e. calls <a class="el" href="classomnetpp_1_1cGate.html#a77e92339332cca84b80d3e79830481df">getPreviousGate()</a> repeatedly) for the transmission channel. It is guaranteed that there can be at most one such channel per path. If no transmission channel is found, the method throws an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classomnetpp_1_1cGate.html#a9e3529d9cd372a21c53895a916712762">getTransmissionChannel()</a>, <a class="el" href="classomnetpp_1_1cChannel.html#ac53b59d9f96b7607a5b47d198bce5f3a">cChannel::isTransmissionChannel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aece09f68af428e9b262ffb76b640ee6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cChannel.html">cChannel</a>* findIncomingTransmissionChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classomnetpp_1_1cGate.html#aed0af0600d5e1da9d81e8d52d3e444da">getIncomingTransmissionChannel()</a>, but returns nullptr instead of throwing an error if there is no transmission channel in the reverse path. </p>

</div>
</div>
<a class="anchor" id="a77e92339332cca84b80d3e79830481df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a>* getPreviousGate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the previous gate in the series of connections (the path) that contains this gate, or nullptr if this gate is the first one in the path. (E.g. for a simple module output gate, this function will return nullptr.) </p>

</div>
</div>
<a class="anchor" id="a03438d6cb4ec2a861c729f82335f7e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a>* getNextGate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next gate in the series of connections (the path) that contains this gate, or nullptr if this gate is the last one in the path. (E.g. for a simple module input gate, this function will return nullptr.) </p>

</div>
</div>
<a class="anchor" id="aa17ba685a1e498ba22647e91fd6bcaf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getConnectionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an ID that uniquely identifies the connection between this gate and the next gate in the path (see <a class="el" href="classomnetpp_1_1cGate.html#a03438d6cb4ec2a861c729f82335f7e89">getNextGate()</a>) during the lifetime of the simulation. (Disconnecting and then reconnecting the gate results in a new connection ID being assigned.) The method returns -1 if the gate is unconnected. </p>

</div>
</div>
<a class="anchor" id="a5b6bfa5cda168821e95a11397610496f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a>* getPathStartGate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ultimate source of the series of connections (the path) that contains this gate. </p>

</div>
</div>
<a class="anchor" id="a64b67f6a8857e2d7e8326f8aafc7df80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a>* getPathEndGate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ultimate destination of the series of connections (the path) that contains this gate. </p>

</div>
</div>
<a class="anchor" id="a7f7d353255f15867f6c98a7a1d87d243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pathContains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classomnetpp_1_1cModule.html">cModule</a> *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gateId</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a given module is in the path containing this gate. </p>

</div>
</div>
<a class="anchor" id="a22a38f2ea3c0b00d96f6f99db4e6c168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnectedOutside </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the gate is connected outside (i.e. to one of its sibling modules or to the parent module).</p>
<p>This means that for an input gate, <a class="el" href="classomnetpp_1_1cGate.html#a77e92339332cca84b80d3e79830481df">getPreviousGate()</a> must be non-nullptr; for an output gate, <a class="el" href="classomnetpp_1_1cGate.html#a03438d6cb4ec2a861c729f82335f7e89">getNextGate()</a> must be non-nullptr. </p>

</div>
</div>
<a class="anchor" id="a56ca27fb38ca92ff6a93c8955ee0ef11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnectedInside </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the gate (of a compound module) is connected inside (i.e. to one of its submodules).</p>
<p>This means that for an input gate, <a class="el" href="classomnetpp_1_1cGate.html#a03438d6cb4ec2a861c729f82335f7e89">getNextGate()</a> must be non-nullptr; for an output gate, <a class="el" href="classomnetpp_1_1cGate.html#a77e92339332cca84b80d3e79830481df">getPreviousGate()</a> must be non-nullptr. </p>

</div>
</div>
<a class="anchor" id="a180fa55a4bf36580963bed9e3e09c227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the gate fully connected. For a compound module gate this means both <a class="el" href="classomnetpp_1_1cGate.html#a56ca27fb38ca92ff6a93c8955ee0ef11">isConnectedInside()</a> and <a class="el" href="classomnetpp_1_1cGate.html#a22a38f2ea3c0b00d96f6f99db4e6c168">isConnectedOutside()</a> are true; for a simple module, only <a class="el" href="classomnetpp_1_1cGate.html#a22a38f2ea3c0b00d96f6f99db4e6c168">isConnectedOutside()</a> is checked. </p>

</div>
</div>
<a class="anchor" id="a069277ac44de9fa0e5586d38565fab66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isPathOK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the path (chain of connections) containing this gate starts and ends at a simple module. </p>

</div>
</div>
<a class="anchor" id="a874774b4a34846e019c7341998c26e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomnetpp_1_1cDisplayString.html">cDisplayString</a>&amp; getDisplayString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the display string for the gate, which controls the appearance of the connection arrow starting from gate. The display string is stored in the channel associated with the connection. If there is no channel, this call creates an installs a <a class="el" href="classomnetpp_1_1cIdealChannel.html" title="Channel with zero propagation delay, zero transmission delay (infinite datarate), and always enabled...">cIdealChannel</a> to hold the display string. </p>

</div>
</div>
<a class="anchor" id="a5fca7be71b1a08f7272233e8b96c2591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDisplayString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dispstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut to <code><a class="el" href="classomnetpp_1_1cGate.html#a874774b4a34846e019c7341998c26e91">getDisplayString()</a>.set(dispstr)</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cgate_8h_source.html">cgate.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>omnetpp</b></li><li class="navelem"><a class="el" href="classomnetpp_1_1cGate.html">cGate</a></li>
    <li class="footer">Generated on Thu Apr 14 2016 13:41:00 for OMNeT++ Simulation Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
